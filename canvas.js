//each user needs

/*username (asked for on connection)
id (dynamically generated by connection order)
each will own a layer

on connection
websocket listening for drawing actions*/

// user class

class user {
    #name = "username";
    #id = null;
    #color = "#0000ff";
    #actions = []; // array of actions
    constructor (name, color, id) {
        this.name = name,
        this.id = id,
        this.color = color;
    }
}

// draw on offscreen canvases -> associate each with a layer

// layers are invisible canvases never drawn on document
// user sees a final flat canvas
// user owns a layer (only they can send messages to layer)
// when user clicks on final flat canvas it draws to hidden canvas offscreen
// and then re-renders the canvas based on layers

// when they draw it's sent to server, server then sends final canvas to others and updates canvas on their ends?

class layer {
    // private stuff
    #id;
    #owner = null;
    #visible = true;
    #zindex = 0; // will allow us to render and sort array based on this in case we delete a layer

    #canvas;
    #context;
    #width;
    #height;

    // arrays of undo/redo actions. will probably limit to like 20 actions?
    #undo = [];
    #redo = [];

    // constructor
    constructor(id, width, height, owner = null) {
        this.id = id;
        this.canvas = document.createElement("canvas");
        _setWidthHeight(width, height);
        this.context = this.canvas.getContext( '2d' );
        this.owner = owner;
        setZIndex(zindex);
    }

    setWidthHeight(width, height) {
        this.#width = width;
        this.#height = height;
        this.#canvas.width = width;
        this.#canvas.height = height;
    }
    
    setOwner(owner) {
        this.#owner = owner;
    }
    getOwner() {
        return this.#owner;
    }
    freeOwner() {
        this.#owner = null;
    }
    setZIndex(zindex) {
        this.#zindex = zindex;
    }
    getCanvas() {
        return this.#canvas;
    }
    toggleVisible() {
        this.#visible = (this.#visible === true) ? false : true; 
    }
    clear() {
        this.#context.clearRect(0, 0, canvas.width, canvas.height);
        return true;
    }
    draw(mouse_pos, color, source_image) {
        // make a brush that's a source image?
    }
    
}

class layer_canvas {
    #layers = layer[0];
    #id;
    #canvas;
    #context;
    #width;
    #height;
    constructor(id, width, height) {
        this.id = id;
        this.canvas = document.createElement("canvas");
        this.width = width;
        this.height = height;
        this.canvas.width = this.width;
        this.canvas.height = this.height;

        this.context = this.canvas.getContext( '2d' );
    }
    
    addLayer(num_layers) {
        try {
            let starting_id = this.#layers.length;
            for(var loop = 0; loop < num_layers; loop++) {
                this.#layers.push(new layer(starting_id + loop, this.#width, this.#height)); // create layer of matching height/width
            }
            console.log(`layers is ${this.#layers}`);

        } catch(error) {
            console.log(`Error! ${error.message}`);
        }
    }
    
    setLayerOwner(owner_id, layer_id) {

    }

    reorderLayer(layer_id, direction) {
        
    }


    clearForRendering() {
        this.#context.clearRect(0, 0, canvas.width, canvas.height);
        return true;
    }

    render() {
        try {
            this.#layers.forEach(layer => {
                if (show) {
                    this.#canvas.drawImage(layer.getCanvas(), 0, 0);
                }

            });
        } catch(error) {
            console.log(`Error! ${error.message}`);
        }
    }

    clearOneLayer(id) {
        try {
            let layer_to_clear = this.#layers.find((lyr) => lyr.id == id);
            layer_to_clear.clear();

        } catch(error) {
            console.log(`Error! ${error.message}`);

        }
        this.#context.clearRect(0, 0, canvas.width, canvas.height);
        return true;
    }
    
    clearAllLayers() {
        try {
            this.#layers.forEach(layer => {
                layer.clear();

            });
        } catch(error) {
            console.log(`Error! ${error.message}`);
        }
    }
}